@*
// Copyright (c) 2010-2012 SharpDX - Alexandre Mutel
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.       
// -------------------------------------------------------------------------------
// Override this template to modify the generated C# syntax of a member
// -------------------------------------------------------------------------------
*@
@model SharpDoc.TemplateContext
@using System.Text;
@using SharpDoc.Model

@functions {

    /// <summary>
    /// Dump the C# syntax of a type (class, interface, struct, enum)
    /// </summary>
    /// <param name="type"></param>
    /// <returns></returns>
    protected string DumpType(NType type) {
        var text = new StringBuilder();

        // Append attributes        
        foreach(var attribute in type.Attributes)
            text.Append("[").Append(attribute).Append("]").AppendLine();
        
        // Append visibility
        text.Append(type.VisibilityName).Append(" ");
        if (type.IsStatic) text.Append("static ");
        if (type.IsAbstract && !(type is NInterface)) text.Append("abstract ");
        if (type.IsFinal) text.Append("sealed ");

        // Append type (class, struct, interface, enum, delegate)
        text.Append(type.TypeName.ToLower()).Append(" ");

        // Append the name
        text.Append(Escape(type.Name));

        bool hasBase = type is NClass && type.Bases.Count > 1;
        if (hasBase)
            text.Append(" : ").Append(Escape(type.Bases[0].Name));
        
        if (type.Interfaces.Count > 0) {
            if (!hasBase)
                text.Append(" : ");
            for(int i = 0; i < type.Interfaces.Count; i++) {
                if (i > 0 || hasBase)
                    text.Append(", ");
                text.Append(Escape(type.Interfaces[i].Name));                
            }
        }
        
        // TODO add generic constraints here
        
        return text.ToString();
    }


    /// <summary>
    /// Dump the C# syntax of a type method
    /// </summary>
    /// <param name="method"></param>
    /// <returns></returns>
    protected string DumpMethod(NMethod method)
    {
        var text = new StringBuilder();

        // Append attributes        
        foreach (var attribute in method.Attributes)
            text.Append("[").Append(attribute).Append("]").AppendLine();

        // Append visibility
        text.Append(method.VisibilityName).Append(" ");
        if (method.IsStatic) text.Append("static ");
        if (method.IsAbstract) text.Append("abstract ");
        if (method.IsFinal) text.Append("sealed ");

        // Append the return type
        text.Append(Escape(method.ReturnType.Name)).Append(" ");
        
        // Append the name
        text.Append(Escape(method.Name)).Append("(");

        if (method.Parameters.Count > 0)
        {
            text.AppendLine();
            for (int i = 0; i < method.Parameters.Count; i++)
            {
                if (i > 0)
                    text.Append(", ").AppendLine();
                text.Append("\t").Append(Escape(method.Parameters[i].ParameterType.Name)).Append(" ").Append(Escape(method.Parameters[i].Name));
            }
            text.AppendLine();
        }
        text.Append(")");

        // TODO add generic constraints here

        return text.ToString();
    }    
    
}


@helper Dump(NMember member)
{
    if (member is NType)
    {
        @DumpType((NType)member);
    } else if (member is NMethod)
    {
        @DumpMethod((NMethod)member);
    }
}
